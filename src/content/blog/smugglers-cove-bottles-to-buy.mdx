---
title: "Smuggler's Cove: Calculating the Best Bottles to Buy"
description: "Smuggler's Cove is my Tiki drink bible, but it's quite expansive in what ingredients it calls for. Let's solve for the best selection of bottles & ingredients to buy."
publishDate: 2024-02-14
---

[Smuggler's Cove](https://www.smugglerscovesf.com/book) by Martin Cate came to me in the deepest depths of the COVID pandemic, where I was looking desperately for things to do with my time. I'd been given an extra copy by my sister-in-law who loved making drinks from it. I was quite intimidated. It's beautiful, it's expansive, it's uncompromising.

So I started with making the Mai Tai. Then next, the Planter's Punch. Then the Zombie. After _just those three drinks_, I'd amassed an impressive collection of bottles. Looking into the rest of the recipes in the book, I had no idea where to go. Buying good rum and ingredients is a spendy endeavour, and I want to know what I'm in for here.

## Formulating the Question: What to Buy?

Let's scope the problem. One can find the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient) of the _n_ available ingredients and the _k_ we'd select as a subset. So we're asking:

- _n_ ingredients to choose from - Which ones?
- _k_ number of ingredients to purchase - How many should we purchase?

Concisely expressed using factorials, the way to solve these looks like:

```
<insert n choose k calculation image here>
```

Suitably, this is often called an _"n choose k"_ calculation. Solving a problem of this type with all possible subsets can quickly become _insanely computationally expensive_. As an example, a selection of 10 bottles from the 72 mentioned (and that's just alcohol, not other ingredients) in the book yields roughly **536 billion possible selections of bottles**. So I'll have to narrow it down a bit.

### The Stats

Smuggler's Cove has [133 ingredients](https://github.com/zmsy/optimal-smugglers-cove/blob/main/metadata.csv) used across its 115 recipes, of which 72 are bottles of alcohol in some form (liquor, liqueurs, bitters, beers, wines, amari, etc). I used the [Smuggler's Cove Index that was posted on reddit a few years back](https://www.reddit.com/r/cocktails/comments/5um8zh/smugglers_cove_tiki_cocktail_book_index/), and did some data cleanup + added metadata for each of the ingredients within.

Limiting the selection to _just_ bottles of alcohol gives us a meaningful reduction in search space: Most of the time the alcohol is the most expensive portion of a recipe and the least easily obtained. The rest of the ingredients are largely purchased at a supermarket or, less often, ordered online at a specialty shop.

### Just Choose the Most Frequent Ones, Right? Maybe Not.

A simple approach would be to find the bottles that appear the most often. Unfortunately, the problem is one of combinatorics, and we want to choose bottles such that it optimizes for the number of additional drinks we can make. Statistically, we want bottles with high [co-occurrence](https://en.wikipedia.org/wiki/Co-occurrence) when measuring pairwise ingredient compatibility.

Let's say you've got these drinks, using some made up data here:

```yaml
# drink -> list of ingredients
drink_1: ["A", "C", "D"]
drink_2: ["A", "E"]
drink_3: ["B", "F"]
drink_4: ["B", "G", "H"]
```

Ingredients `'A'` and `'B'` both occur in 50% of the recipes, but have zero co-occurrences. If you've got a set with `'A'`, `'C'`, and `'D'` in it, adding `'B'` doesn't give you any additional drinks you can make, but adding `'E'` would. Most frequent elements _may_ give you an optimal subset of ingredients, but they're not guaranteed to.

## Finding a Solution: Enter the CP-SAT Solver

Naively trying to enumerate + try every subset seems like it would be brutally difficult, or finding some sort of optimal subproblem that could be aggregated.

I opted to use **Google's [OR-Tools](https://developers.google.com/optimization/introduction)**, which is a toolkit that bills itself as "open source software for combinatorial optimization, which seeks to find the best solution to a problem out of a very large set of possible solutions". Most specifically, I use the [CP-SAT solver](https://developers.google.com/optimization/cp/cp_solver) in Python.

This allows one to **express a problem in terms of variables, constraints and objectives**, and the solver will do the hard work of figuring out the best solution for you. No hand-rolling your own optimizations required! Using [the example from the docs](https://developers.google.com/optimization/cp/cp_solver), it looks like:

- **Variables** are used to designate your search space. Imagine three variables `x`, `y,` and `z` that can be either 0, 1, or 2.
- **Constraints** are a way to phrase how you'd like to maximize for a specific criteria. We want `x != y`.

The model will give you every combination of values for `x`, `y`, and `z` that follow the constraint `x != y`.

```txt
x=1 y=0 z=0
x=2 y=0 z=0
x=2 y=1 z=0
x=2 y=1 z=1
x=2 y=1 z=2
...etc
```

This, however, just gives you all of the options available. So how do you describe the optimal solution? You can add **an [objective function](https://developers.google.com/optimization/cp/cp_example#define_the_objective_function)** to get that. Let's say you want the highest value of all options when added together.

```python
# set the objective function for the model so that it gives you the best output.
model.Maximize(x + y + z)
```

A little napkin math will tell you that the result is `5`, but you can also plug in more complex functions of `x`, `y` and `z` to meet your use case.

### The Best _n_ Bottles to Buy

So how would one model the constraints for Smuggler's Cove in a way that it finds us the best selection of bottles? Let's plug in our criteria. This first example will solve for the **optimal set of _n_ bottles to make the largest number of cocktails**, where _n_ is a number of my choosing.

### Ingredients

Ingredients can be modeled as booleans. They're present (1) or not (0) within a drink recipe.

```python

# first, create the model
from ortools.sat.python import cp_model
model = cp_model.CpModel()

# create a dictionary comprehension of all ingredient names -> variables
ingredient_vars = {x: model.NewBoolVar(x) for x in ingredients}

# require that the model only have the number of ingredients that we've asked it
# for. so if we want the best 5 bottles, it'll give us the best 5 bottles.
model.Add(sum(ingredient_vars.values()) == n)  # n = number I want
```

### Drinks

Each drink can also be modeled as a boolean, but we need to make sure that they're constrained such that being able to make a drink requires _every_ ingredient used.

```python
drink_vars = []
for drink in drinks:
    required_ingredient_vars = [ingredient_vars[x] for x in drink.ingredients]
    drink_var = model.NewBoolVar(drink.name)
    model.AddBoolAnd(required_ingredient_vars).OnlyEnforceIf(drink_var)
    drink_vars.append(drink_var)
```

### Optimization Function

Once your relationship between drinks and ingredients is found, you can use the _number of drinks_ with each subset to become your objective.

```python
# higher sum of drinks = better outcome
model.Maximize(sum(drink_vars))
```

## Determining the Right Number (_n_) of Bottles

So this will give you the best available subset of bottles to maximize how many drinks one can make given a subset size, but how does one know how many to aim for? There's a few different strategies. I'll show you the answers for each one.
